#include<stdio.h>

int main()
{
    //int a[4] = { 1,2,3,4 };
    //int* ptr1 = (int*)(&a + 1);//&a+1是数组最后一个元素后一个地址指针，然后转换为整形指针
    //int* ptr2 = (int*)((int)a + 1);//数组指针转化为整形，然后+1（向后加一）再转换整形指针（和之前相比向后+1字节）
    ////数组a在内存中：01000000  02000000 03000000 04000000小端存储
    //// ptr2指向01后面这个地址*ptr2向后访问4个字节是00000002转化为16进制0x02000000
    //// ptr[-1]==*(ptr-1),ptr是数组最后一个元素后面一个指针，ptr-1是ptr向前移动一个字节（指向04000000）16进制是0x00000004
    ////%x打印16进制数字
    //printf("%x,%x", ptr1[-1], *ptr2);//04000000）16进制是0x00000004，00000002转化为16进制0x02000000
    //return 0;

    //int a[3][2] = { (0,1),(2,3),(4,5)};//逗号表达式（最后一个表达式是最终值），（0，1）计算结果就是1
    ////数组内放的只是{1，3，5}
    //int* p;
    //p = a[0];//a[0]是数组名（没有单独放在sizeof内）所以是首元素地址（即第一行数组第一个元素地址）
    //printf("%d", p[0]);//p[0]==*（p+0)解引用第一行第一个元素地址

    //int a[5][5];
    //int(*p)[4];
    //p = a;//警告，p的类型是int(*p)[4],a的类型是int(*)[5]。a是第一行数组地址
    ////强行赋值后p指向首元素地址处
    ////&a[4][2]是元素a[4][2]的地址
    ////p[1]将p向后走4个字节p[4][2]==*(*(p+4)+2)
    //printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
    ////指针-指针得到中间元素个数&p[4][2] - &a[4][2]=-4，%d打印-4，%p是无符号概念，直接将-4的补码当作地址打印出来
    ////FFFFFFFFFFFFFFFC,-4
    
    //int aa[2][5] = { 1,2,3,4,5,6,7,8,9,10 };
    //int* ptr1 = (int*)(&aa + 1);//&aa取整个数组大小，&aa+1跳过这个数组
    ////转换int*后每次跳4个字节
    //int* ptr2 = (int*)(*(aa + 1));//*(aa + 1)==aa[1].aa是第一行数组地址aa+1是第二行数组地址,再解引用相当于拿到第二行数组名
    ////即第二行数组首元素地址6的地址
    ////int*多余（6的地址已经是int*)
    //printf("%d,%d\n", *(ptr1 - 1), *(ptr2 - 1));//打印10,6

   // char* a[] = { "work","at","alibaba" };
   ////类似char*p="abcd","abcd"是常量字符窜，p存放a的地址
   // //a是字符指针数组：存放的是w,a,a的地址
   //
   // char** pa = a;//数组名：首元素地址即w地址的地址
   // pa++;//跳过一个char*变量，指向数组a第二个元素地址即a地址的地址
   // printf("%s\n", *pa);//*pa-a的地址，%s打印字符窜，以a的地址开头打印字符窜即“at"

    char* c[] = { "ENTER","NEW","POINT","FIRST" };
    char** cp[] = { c + 3,c + 2,c + 1,c };
    char*** cpp = cp;
    printf("%s\n", **++cpp);
    //CPP++指向c+2的地址,解引用得到c+2,再解引用得P素地址,从P地址开始打印得POINT.
    printf("%s\n", *-- * ++cpp + 3);
    //++CPP（上一次基础上再++）指向C + 1的地址.*++CPP得到C + 1, --* ++CPP得到C, * C得到E的地址。
    //再 + 3向后走三个字符变量得到ENTER中的第二个E的地址，打印ER.
    printf("%s\n", *cpp[-2] + 3);
    //(这里CPP指向C+1地址)CPP[-2]==*(CPP-2)得到C+3，（CPP未改变只是用了CPP-2这个表达式的值）*CPP[-2]得到F地址，再+3得到S地址，打印ST
    printf("%s\n", cpp[-1][-1] + 1);
    //CPP[-1]==*(CPP-1)得到C+2,CPP[-1][-1]==*(C+2-1)==*(C+1)得到N地址。再+1得到NEW中E的地址，打印EW.















    return 0;
}